syntax = "proto3";
option go_package = "pipeline";

import "google/protobuf/descriptor.proto";
import "google/protobuf/timestamp.proto";

import "pipeline.proto";
import "primitive.proto";
import "problem.proto";
import "value.proto";

extend google.protobuf.FileOptions {
    // 54100 is from the range reserved for internal use within individual organizations.
    // If we will make this protocol public, we should obtain globally unique field number from Google.
    string protocol_version = 54100;
}

// Date-based version string. Use is it to populate version in "SearchPipelinesRequest"
// and "SearchPipelinesResponse" messages.
option (protocol_version) = "2018.1.7_pre";

enum EvaluationMethod {
    // Default value. Not to be used.
    EVALUATION_METHOD_UNDEFINED = 0;

    // The following are the only evaluation methods required
    // to be supported for the "ScorePipeline" call.
    HOLDOUT = 1;
    K_FOLD = 2;

    // The rest are defined to allow expressing internal evaluation
    // methods used by TA2 during pipeline search. If any you are using
    // is missing, feel free to request it to be added.
    LEAVE_ONE_OUT = 100;
    // Instead of really scoring, a TA2 might predict the score only.
    PREDICTION = 101;
    // Training data is reused to test as well.
    TRAINING_DATA = 102;
}

message ScoringConfiguration {
    // The evaluation method to use.
    EvaluationMethod method = 1;
    // Number of folds made, if applicable.
    int32 folds = 2;
    // Ratio of train set vs. test set, if applicable.
    double train_test_ratio = 3;
    // Shuffle data?  If applicable.
    bool shuffle = 4;
    // Fix random seed to use for shuffling. Optional.
    int32 random_seed = 5;
    // Do stratified k-fold? If applicable.
    bool stratified = 6;
}

message Score {
    ProblemPerformanceMetric metric = 1;
    Value value = 2;
}

// Updates problem with new description. This upates problem description also for all
// ongoing pipeline searches associated with this problem. Internal behavior of TA2
// is unspecified: it can simply start a new search using new problem description, or
// it can start modifying pipelines it has already found to new problem description, or
// it can use it to help narrow down onging pipeline search further. In any case, after
// this call returns, all found pipelines for searches associated with this problem
// should be for the updated problem description.
message UpdateProblemRequest {
    string search_id = 1;
    // New problem description. It has to be provided in full and it replaces existing
    // problem description.
    ProblemDescription problem = 2;
}

message UpdateProblemResponse {}

// Starts a new pipeline search. Found pipelines have not necessary be fitted on the provided
// inputs. Problem description and inputs are used only to help guide the search process.
// Consider found pipelines just a static descriptions of pipelines at this stage.
// Multiple parallel pipeline searches can happen at the same time.
message SearchPipelinesRequest {
    // Some string identifying the name and version of the TA3 system.
    string user_agent = 1;
    // Shall be set to "protocol_version" above.
    string version = 2;
    // Which value types can a TA2 system use to communicate values to a TA3 system?
    // The order is important as TA2 system will try value types in order until one works out,
    // or an error will be returned instead of the value.
    repeated ValueType allowed_value_types = 3;
    // Problem description to use for the pipeline search.
    ProblemDescription problem = 4;
    // A pipeline template to use for search or to execute. If template is ommited, then a
    // regular pipeline search is done. If template consists only of one placeholder step,
    // then a regular pipeline search is done to replace that step. If there is no placeholder
    // step, but template describes a full pipeline with free hyper-parameters, then this
    // call becomes a hyper-paramater tuning call over free hyper-paramaters and found pipelines
    // share the same pipeline, but different hyper-parameter configurations. If there is no
    // placeholder step and all hyper-parameters are fixed as part of the pipeline, then this
    // call only checks the given template and returns the same pipeline back, to be execeuted.
    // This allows fixed computations to be done on data, for example, pipeline can consist
    // of only one primitve with fixed hyper-parameters to execute that one primitive.
    // Moreover, such fully specified pipeline with fixed hyper-parametres can have any
    // inputs and any outputs. Otherwise pipelines have to be from a Dataset container value
    // to predictions.
    PipelineDescription template = 5;
    // Pipeline inputs used during pipeline search. They have to point to be Dataset container
    // values. Order matters as each input is mapped to template's input in order. Optional
    // for templates without a placeholder and with all hyper-parameters fixed.
    repeated Value inputs = 6;
}

// Call returns immediatelly with the ID. Use "GetFoundPipelines" call to get results.
message SearchPipelinesResponse {
    // An ID identifying this pipeline search. This string should be at least 22 characters
    // long to ensure enough entropy to not be guessable.
    string search_id = 1;
    // Some string identifying the name and version of the TA2 system.
    string user_agent = 2;
    // Shall be set to "protocol_version" above.
    string version = 3;
}

// Ends the search and releases all resources associated with the pipeline search.
// If the call is made in parallel with a running search and results are being streamed,
// the search is stopped and the "GetSearchPipelinesResults" stream is closed by TA2
// (as it happens when the search is concluded on its own, or when search is stopped
// by "StopSearchPipelines"). Found pipeline IDs during the search are not usable
// anymore after this call.
message EndSearchPipelinesRequest {
    string search_id = 1;
}

message EndSearchPipelinesResponse {}

// Stops the search but leaves all already found pipelines available.
// If the call is made in parallel with a running search and results are being streamed,
// the "GetSearchPipelinesResults" stream is closed by TA2 (as it happens when the search
// is concluded on its own). Search cannot be re-started after it has been stopped.
message StopSearchPipelinesRequest {
    string search_id = 1;
}

message StopSearchPipelinesResponse {}

// Decription of a TA2 score done during pipeline search. Because there is a wide range of potential
// approaches TA2 can use to score candidate pipelines this might not capture what your TA2 is doing.
// Feel free to request additions to be able to describe your approch.
message PipelineSearchScore {
    ScoringConfiguration scoring_configuration = 1;
    Score score = 2;
}

// Get all pipelines found until now during the search and start receiving any
// new pipeline found as well.
message GetSearchPipelinesResultsRequest {
    string search_id = 1;
}

message GetSearchPipelinesResultsResponse {
    string pipeline_id = 1;
    // Internal score for this pipeline between 0.0 and 1.0 where 1.0 is the highest score.
    // There is no other meaning to this score and it does not necessary depend on scores
    // listed in the problem description. Optional.
    // Becaue this field is optional, if omitted the default value will be 0. But 0 is a
    // valid value for this field. Because of that you should never omit the field.
    // If you do not have internal score to provide, use NaN for the value of this field
    // to signal that.
    double internal_score = 2;
    // TA2 might be able to provide more meaningful scores as well, depending on its
    // approach to pipeline search. Moreover, even same TA2 might not use same scoring
    // approach for all its pipelines. Optional.
    repeated PipelineSearchScore scores = 3;
}

// Request a detailed description of the found pipeline.
message DescribePipelineRequest {
    string pipeline_id = 1;
}

message PrimitiveStepDescription {
    // Selected value for free pipeline hyper-parameters.
    map<string, Value> hyperparams = 1;
}

message SubpipelineStepDescription {
    // Each step in a sub-pipeline has description as well. In order of steps in the sub-pipeline.
    repeated StepDescription steps = 1;
}

message StepDescription {
    oneof step {
        PrimitiveStepDescription primitive = 1;
        SubpipelineStepDescription pipeline = 2;
    }
}

message DescribePipelineResponse {
    // A pipeline description. Nested pipelines should be fully described as well.
    PipelineDescription pipeline = 1;
    // Each step in a pipeline has description as well. In order of steps in the pipeline.
    repeated StepDescription steps = 2;
}

// After "progress" becomes "COMPLETED" or "ERRORED" stream closes.
enum Progress {
    // Default value. Not to be used.
    PROGRESS_UNKNOWN = 0;

    // The process has been scheduled but is pending execution.
    PENDING = 1;
    // The process is currently running. There can be multiple messages with this state
    // (while the process is running).
    RUNNING = 2;
    // The process completed and final results are available.
    COMPLETED = 3;
    // The process failed.
    ERRORED = 4;
}

message StepProgress {
    Progress progress = 1;
    // If step failed, why.
    string failure = 2;
    google.protobuf.Timestamp start = 3;
    google.protobuf.Timestamp end = 4;
    // If step is a sub-pipeline, then this list contains progress for each step in the sub-pipeline, in order.
    // List can be incomplete while the process is in progress.
    repeated StepProgress steps = 5;
}


// User associated with the run of the pipeline.
message PipelineRunUser {
    // A UUID of the user. It does not have to map to any real ID, just that it is possible
    // to connect mutliple pipeline actions by the same user together, if necessary.
    string id = 1;
    // Was this run because pipeline was choosen by this user.
    bool choosen = 2;
    // Textual reason provided by the user why the run was choosen by this user.
    string reason = 3;
}

// Request pipeline to be scored given inputs. Inputs have to be Dataset container values
// and pipeline outputs have to be predictions. It can internally run multiple fit + produce runs
// of the pipeline on permutations of inputs data (e.g., for cross-validation). This is also
// why we cannot expose outputs here.
message ScorePipelineRequest {
    string pipeline_id = 1;
    repeated Value inputs = 2;
    repeated ProblemPerformanceMetric performance_metrics = 3;
    // Any users associated with this call itself. Optional.
    repeated PipelineRunUser users = 4;
    ScoringConfiguration configuration = 5;
}

message ScorePipelineResponse {
    string request_id = 1;
}

// Get all score results computed until now and start receiving any
// new score results computed as well.
message GetScorePipelineResultsRequest {
    string request_id = 1;
}

message GetScorePipelineResultsResponse {
    // Overall process progress.
    Progress progress = 1;
    // Failure which prevented scoring.
    string failure = 2;
    google.protobuf.Timestamp start = 3;
    google.protobuf.Timestamp end = 4;
    // List of score results. List can be incomplete while the process is in progress.
    repeated Score scores = 5;
}

// Fit the pipeline on given inputs. If a pipeline is already fitted on inputs this is a noop
// (if no additional outputs should be exposed). This can happen when TA2 fits the pipeline
// already during pipeline search phase.
message FitPipelineRequest {
    string pipeline_id = 1;
    repeated Value inputs = 2;
    // List of data references of step outputs which should be exposed to the TA3 system.
    // If you want to expose outputs of the whole pipeline (e.g., predictions themselves),
    // list them here as well. These can be recursive data references like "steps.1.steps.4.produce"
    // to point to an output inside a sub-pipeline.
    repeated string expose_outputs = 3;
    // Which value types should be used for exposing outputs. If not provided, the allowed
    // value types list from hello call is used instead.
    // The order is important as TA2 system will try value types in order until one works out,
    // or an error will be returned instead of the value. An error exposing a value does not stop
    // the overall process.
    repeated ValueType expose_value_types = 4;
    // Any users associated with this call itself. Optional.
    repeated PipelineRunUser users = 5;
}


message FitPipelineResponse {
    string request_id = 1;
}

// Get all fitting results computed until now and start receiving any
// new fitting results computed as well.
message GetFitPipelineResultsRequest {
    string request_id = 1;
}

message GetFitPipelineResultsResponse {
    // Overall process progress.
    Progress progress = 1;
    // Failure which prevented pipeline to run at all.
    string failure = 2;
    google.protobuf.Timestamp start = 3;
    google.protobuf.Timestamp end = 4;
    // The ist contains progress for each step in the pipeline, in order.
    // List can be incomplete while the process is in progress.
    repeated StepProgress steps = 5;
    // A mapping between data references of step outputs and values.
    map<string, Value> exposed_outputs = 6;
}

// Produce the pipeline on given inputs. A pipeline has to be fitted for this to be possible
// (even if it is full of just transformations).
message ProducePipelineRequest {
    string pipeline_id = 1;
    repeated Value inputs = 2;
    // List of data references of step outputs which should be exposed to the TA3 system.
    // If you want to expose outputs of the whole pipeline (e.g., predictions themselves),
    // list them here as well. These can be recursive data references like "steps.1.steps.4.produce"
    // to point to an output inside a sub-pipeline.
    repeated string expose_outputs = 3;
    // Which value types should be used for exposing outputs. If not provided, the allowed
    // value types list from hello call is used instead.
    // The order is important as TA2 system will try value types in order until one works out,
    // or an error will be returned instead of the value. An error exposing a value does not stop
    // the overall process.
    repeated ValueType expose_value_types = 4;
    // Any users associated with this call itself. Optional.
    repeated PipelineRunUser users = 5;
}

message ProducePipelineResponse {
    string request_id = 1;
}

// Get all producing results computed until now and start receiving any
// new producing results computed as well.
message GetProducePipelineResultsRequest {
    string request_id = 1;
}

message GetProducePipelineResultsResponse {
    // Overall process progress.
    Progress progress = 1;
    // Failure which prevented pipeline to run at all.
    string failure = 2;
    google.protobuf.Timestamp start = 3;
    google.protobuf.Timestamp end = 4;
    // The ist contains progress for each step in the pipeline, in order.
    // List can be incomplete while the process is in progress.
    repeated StepProgress steps = 5;
    // A mapping between data references of step outputs and values.
    map<string, Value> exposed_outputs = 6;
}

// Exports a pipeline for evaluaton purposes based on NIST specifications.
message PipelineExportRequest {
    // Found pipeline to export.
    string pipeline_id = 1;
    // Pipeline rank to be used for the exported pipeline. Each exported pipeline
    // has rank metadata associated with it. There has to be at least one pipeline
    // exported and only one can and should have rank 1, but assuring this is
    // responsibility of a TA3. If an export of a pipeline is requested again with the
    // same rank as previously (for same or different pipeline), a TA2 system should
    // override the previous export with a new one (or by removing files associated
    // with the previous export and creating new files, or by overriding files with new
    // content). Filenames of exported files are left to be choosen by the TA2 system.
    int32 rank = 2;
}

message PipelineExportResponse {}

// List all primitives known to TA2, their IDs, versions, names, and digests. Using this
// information TA3 knows which primitives to put into pipeline templates. To narrow down
// potential primitives to use TA3 can also first ask TA3 to do a pipeline search and then
// observe which primitives TA2 is using. If more metadata about primitives is needed,
// TA3 can use results of this call to map primitives to metadata (from Python code or
// primitive annotations) on its own.
message ListPrimitivesRequest {}

message ListPrimitivesResponse {
    repeated Primitive primitives = 1;
}

// List which value types can a TA3 system use to communicate values to a TA2 system?
// This call is also suitable for a ping/pong call to check that TA2 is ready.
message ListAllowedValueTypesRequest {}

message ListAllowedValueTypesResponse {
    // Which value types can a TA3 system use to communicate values to a TA2 system?
    // The order is important as TA3 system will try value types in order until one works out,
    // or an error will be returned instead of the value.
    repeated ValueType allowed_value_types = 1;
}

// See each message for more information about each call.
service Core {
    rpc SearchPipelines (SearchPipelinesRequest) returns (SearchPipelinesResponse) {}
    rpc GetSearchPipelinesResults (GetSearchPipelinesResultsRequest) returns (stream GetSearchPipelinesResultsResponse) {}
    rpc EndSearchPipelines (EndSearchPipelinesRequest) returns (EndSearchPipelinesResponse) {}
    rpc StopSearchPipelines (StopSearchPipelinesRequest) returns (StopSearchPipelinesResponse) {}

    rpc DescribePipeline (DescribePipelineRequest) returns (DescribePipelineResponse) {}

    rpc ScorePipeline (ScorePipelineRequest) returns (ScorePipelineResponse) {}
    rpc GetScorePipelineResults (GetScorePipelineResultsRequest) returns (stream GetScorePipelineResultsResponse) {}

    rpc FitPipeline (FitPipelineRequest) returns (FitPipelineResponse) {}
    rpc GetFitPipelineResults (GetFitPipelineResultsRequest) returns (stream GetFitPipelineResultsResponse) {}

    rpc ProducePipeline (ProducePipelineRequest) returns (ProducePipelineResponse) {}
    rpc GetProducePipelineResults (GetProducePipelineResultsRequest) returns (stream GetProducePipelineResultsResponse) {}

    rpc PipelineExport (PipelineExportRequest) returns (PipelineExportResponse) {}

    rpc UpdateProblem (UpdateProblemRequest) returns (UpdateProblemResponse) {}

    rpc ListPrimitives (ListPrimitivesRequest) returns (ListPrimitivesResponse) {}
    rpc ListAllowedValueTypes (ListAllowedValueTypesRequest) returns (ListAllowedValueTypesResponse) {}

}
