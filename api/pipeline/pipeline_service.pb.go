// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pipeline_service.proto

/*
Package pipeline is a generated protocol buffer package.

It is generated from these files:
	pipeline_service.proto

It has these top-level messages:
	Header
	Status
	Result
	SessionRequest
	PipelineCreateRequest
	PipelineCreateComplete
	PipelineCreateResult
	PipelineExecuteRequest
	PipelineExecuteResult
*/
package pipeline

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Task int32

const (
	Task_CLASSIFICATION Task = 0
	Task_REGRESSION     Task = 1
)

var Task_name = map[int32]string{
	0: "CLASSIFICATION",
	1: "REGRESSION",
}
var Task_value = map[string]int32{
	"CLASSIFICATION": 0,
	"REGRESSION":     1,
}

func (x Task) String() string {
	return proto.EnumName(Task_name, int32(x))
}
func (Task) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type SubTask int32

const (
	SubTask_BINARY_CLASSIFICATION     SubTask = 0
	SubTask_MULTICLASS_CLASSIFICATION SubTask = 1
	SubTask_MULTILABEL_CLASSIFICATION SubTask = 2
)

var SubTask_name = map[int32]string{
	0: "BINARY_CLASSIFICATION",
	1: "MULTICLASS_CLASSIFICATION",
	2: "MULTILABEL_CLASSIFICATION",
}
var SubTask_value = map[string]int32{
	"BINARY_CLASSIFICATION":     0,
	"MULTICLASS_CLASSIFICATION": 1,
	"MULTILABEL_CLASSIFICATION": 2,
}

func (x SubTask) String() string {
	return proto.EnumName(SubTask_name, int32(x))
}
func (SubTask) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Output int32

const (
	Output_CLASS_LABEL      Output = 0
	Output_PROBABILITY      Output = 1
	Output_GENERAL_SCORE    Output = 2
	Output_MULTILABEL       Output = 3
	Output_REGRESSION_VALUE Output = 4
)

var Output_name = map[int32]string{
	0: "CLASS_LABEL",
	1: "PROBABILITY",
	2: "GENERAL_SCORE",
	3: "MULTILABEL",
	4: "REGRESSION_VALUE",
}
var Output_value = map[string]int32{
	"CLASS_LABEL":      0,
	"PROBABILITY":      1,
	"GENERAL_SCORE":    2,
	"MULTILABEL":       3,
	"REGRESSION_VALUE": 4,
}

func (x Output) String() string {
	return proto.EnumName(Output_name, int32(x))
}
func (Output) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type Metric int32

const (
	Metric_ACCURACY              Metric = 0
	Metric_PRECISION             Metric = 1
	Metric_RECALL                Metric = 2
	Metric_F1                    Metric = 3
	Metric_F1_MICRO              Metric = 4
	Metric_F1_MACRO              Metric = 5
	Metric_ROC_AUC               Metric = 6
	Metric_LOG_LOSS              Metric = 7
	Metric_MEAN_SQUARED_ERR      Metric = 8
	Metric_ROOT_MEAN_SQUARED_ERR Metric = 9
	Metric_MEAN_ABSOLUTE_ERR     Metric = 10
	Metric_MEDIAN_ABSOSLUTE_ERR  Metric = 11
	Metric_R2                    Metric = 12
)

var Metric_name = map[int32]string{
	0:  "ACCURACY",
	1:  "PRECISION",
	2:  "RECALL",
	3:  "F1",
	4:  "F1_MICRO",
	5:  "F1_MACRO",
	6:  "ROC_AUC",
	7:  "LOG_LOSS",
	8:  "MEAN_SQUARED_ERR",
	9:  "ROOT_MEAN_SQUARED_ERR",
	10: "MEAN_ABSOLUTE_ERR",
	11: "MEDIAN_ABSOSLUTE_ERR",
	12: "R2",
}
var Metric_value = map[string]int32{
	"ACCURACY":              0,
	"PRECISION":             1,
	"RECALL":                2,
	"F1":                    3,
	"F1_MICRO":              4,
	"F1_MACRO":              5,
	"ROC_AUC":               6,
	"LOG_LOSS":              7,
	"MEAN_SQUARED_ERR":      8,
	"ROOT_MEAN_SQUARED_ERR": 9,
	"MEAN_ABSOLUTE_ERR":     10,
	"MEDIAN_ABSOSLUTE_ERR":  11,
	"R2": 12,
}

func (x Metric) String() string {
	return proto.EnumName(Metric_name, int32(x))
}
func (Metric) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type Header struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	Timestamp string `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	Version   string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *Header) Reset()                    { *m = Header{} }
func (m *Header) String() string            { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()               {}
func (*Header) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Header) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *Header) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *Header) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// status code could be an enum, should catpure success, error conditions with details provided
// in the string field
type Status struct {
	Result int32  `protobuf:"varint,1,opt,name=result" json:"result,omitempty"`
	Info   string `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Status) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *Status) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

type Result struct {
	Header *Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Status *Status `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Result) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Result) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type SessionRequest struct {
	Header    *Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	SessionId string  `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *SessionRequest) Reset()                    { *m = SessionRequest{} }
func (m *SessionRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionRequest) ProtoMessage()               {}
func (*SessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SessionRequest) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SessionRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

type PipelineCreateRequest struct {
	Header *Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	// could also split into train_dataset_uri, train_targets_uri if training data left unjoined, would
	// make 'target_features' field redundant in that case
	TrainDatasetUris []string `protobuf:"bytes,2,rep,name=train_dataset_uris,json=trainDatasetUris" json:"train_dataset_uris,omitempty"`
	Task             Task     `protobuf:"varint,3,opt,name=task,enum=pipeline.Task" json:"task,omitempty"`
	SubTask          SubTask  `protobuf:"varint,4,opt,name=subTask,enum=pipeline.SubTask" json:"subTask,omitempty"`
	Output           Output   `protobuf:"varint,5,opt,name=output,enum=pipeline.Output" json:"output,omitempty"`
	Metric           Metric   `protobuf:"varint,6,opt,name=metric,enum=pipeline.Metric" json:"metric,omitempty"`
	TargetFeatures   []string `protobuf:"bytes,7,rep,name=target_features,json=targetFeatures" json:"target_features,omitempty"`
	NumPipelines     int32    `protobuf:"varint,8,opt,name=num_pipelines,json=numPipelines" json:"num_pipelines,omitempty"`
}

func (m *PipelineCreateRequest) Reset()                    { *m = PipelineCreateRequest{} }
func (m *PipelineCreateRequest) String() string            { return proto.CompactTextString(m) }
func (*PipelineCreateRequest) ProtoMessage()               {}
func (*PipelineCreateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PipelineCreateRequest) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *PipelineCreateRequest) GetTrainDatasetUris() []string {
	if m != nil {
		return m.TrainDatasetUris
	}
	return nil
}

func (m *PipelineCreateRequest) GetTask() Task {
	if m != nil {
		return m.Task
	}
	return Task_CLASSIFICATION
}

func (m *PipelineCreateRequest) GetSubTask() SubTask {
	if m != nil {
		return m.SubTask
	}
	return SubTask_BINARY_CLASSIFICATION
}

func (m *PipelineCreateRequest) GetOutput() Output {
	if m != nil {
		return m.Output
	}
	return Output_CLASS_LABEL
}

func (m *PipelineCreateRequest) GetMetric() Metric {
	if m != nil {
		return m.Metric
	}
	return Metric_ACCURACY
}

func (m *PipelineCreateRequest) GetTargetFeatures() []string {
	if m != nil {
		return m.TargetFeatures
	}
	return nil
}

func (m *PipelineCreateRequest) GetNumPipelines() int32 {
	if m != nil {
		return m.NumPipelines
	}
	return 0
}

type PipelineCreateComplete struct {
	ResultUris []string `protobuf:"bytes,1,rep,name=result_uris,json=resultUris" json:"result_uris,omitempty"`
	Output     Output   `protobuf:"varint,2,opt,name=output,enum=pipeline.Output" json:"output,omitempty"`
	Metric     Metric   `protobuf:"varint,3,opt,name=metric,enum=pipeline.Metric" json:"metric,omitempty"`
	Score      float32  `protobuf:"fixed32,4,opt,name=score" json:"score,omitempty"`
}

func (m *PipelineCreateComplete) Reset()                    { *m = PipelineCreateComplete{} }
func (m *PipelineCreateComplete) String() string            { return proto.CompactTextString(m) }
func (*PipelineCreateComplete) ProtoMessage()               {}
func (*PipelineCreateComplete) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *PipelineCreateComplete) GetResultUris() []string {
	if m != nil {
		return m.ResultUris
	}
	return nil
}

func (m *PipelineCreateComplete) GetOutput() Output {
	if m != nil {
		return m.Output
	}
	return Output_CLASS_LABEL
}

func (m *PipelineCreateComplete) GetMetric() Metric {
	if m != nil {
		return m.Metric
	}
	return Metric_ACCURACY
}

func (m *PipelineCreateComplete) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

type PipelineCreateResult struct {
	Header     *Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Status     *Status `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	PipelineId string  `protobuf:"bytes,3,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
	// Will be unset if pipeline creation is still in progress - status field
	// can be used to provide progress info
	CompleteInfo *PipelineCreateComplete `protobuf:"bytes,4,opt,name=completeInfo" json:"completeInfo,omitempty"`
}

func (m *PipelineCreateResult) Reset()                    { *m = PipelineCreateResult{} }
func (m *PipelineCreateResult) String() string            { return proto.CompactTextString(m) }
func (*PipelineCreateResult) ProtoMessage()               {}
func (*PipelineCreateResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PipelineCreateResult) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *PipelineCreateResult) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *PipelineCreateResult) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

func (m *PipelineCreateResult) GetCompleteInfo() *PipelineCreateComplete {
	if m != nil {
		return m.CompleteInfo
	}
	return nil
}

type PipelineExecuteRequest struct {
	Header          *Header  `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	PipelineId      string   `protobuf:"bytes,2,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
	TestDatasetUris []string `protobuf:"bytes,3,rep,name=test_dataset_uris,json=testDatasetUris" json:"test_dataset_uris,omitempty"`
}

func (m *PipelineExecuteRequest) Reset()                    { *m = PipelineExecuteRequest{} }
func (m *PipelineExecuteRequest) String() string            { return proto.CompactTextString(m) }
func (*PipelineExecuteRequest) ProtoMessage()               {}
func (*PipelineExecuteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PipelineExecuteRequest) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *PipelineExecuteRequest) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

func (m *PipelineExecuteRequest) GetTestDatasetUris() []string {
	if m != nil {
		return m.TestDatasetUris
	}
	return nil
}

type PipelineExecuteResult struct {
	Header     *Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Status     *Status `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	PipelineId string  `protobuf:"bytes,3,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
	// Will be unser if pipeline execution is still in progress - status field
	// can be used to provide progress info
	ResultUris []string `protobuf:"bytes,4,rep,name=result_uris,json=resultUris" json:"result_uris,omitempty"`
}

func (m *PipelineExecuteResult) Reset()                    { *m = PipelineExecuteResult{} }
func (m *PipelineExecuteResult) String() string            { return proto.CompactTextString(m) }
func (*PipelineExecuteResult) ProtoMessage()               {}
func (*PipelineExecuteResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *PipelineExecuteResult) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *PipelineExecuteResult) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *PipelineExecuteResult) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

func (m *PipelineExecuteResult) GetResultUris() []string {
	if m != nil {
		return m.ResultUris
	}
	return nil
}

func init() {
	proto.RegisterType((*Header)(nil), "pipeline.Header")
	proto.RegisterType((*Status)(nil), "pipeline.Status")
	proto.RegisterType((*Result)(nil), "pipeline.Result")
	proto.RegisterType((*SessionRequest)(nil), "pipeline.SessionRequest")
	proto.RegisterType((*PipelineCreateRequest)(nil), "pipeline.PipelineCreateRequest")
	proto.RegisterType((*PipelineCreateComplete)(nil), "pipeline.PipelineCreateComplete")
	proto.RegisterType((*PipelineCreateResult)(nil), "pipeline.PipelineCreateResult")
	proto.RegisterType((*PipelineExecuteRequest)(nil), "pipeline.PipelineExecuteRequest")
	proto.RegisterType((*PipelineExecuteResult)(nil), "pipeline.PipelineExecuteResult")
	proto.RegisterEnum("pipeline.Task", Task_name, Task_value)
	proto.RegisterEnum("pipeline.SubTask", SubTask_name, SubTask_value)
	proto.RegisterEnum("pipeline.Output", Output_name, Output_value)
	proto.RegisterEnum("pipeline.Metric", Metric_name, Metric_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for PipelineCompute service

type PipelineComputeClient interface {
	// Train step - multiple result messages returned via GRPC streaming.
	CreatePipelines(ctx context.Context, in *PipelineCreateRequest, opts ...grpc.CallOption) (PipelineCompute_CreatePipelinesClient, error)
	// Predict step - multiple results messages returned via GRPC streaming.
	ExecutePipeline(ctx context.Context, in *PipelineExecuteRequest, opts ...grpc.CallOption) (PipelineCompute_ExecutePipelineClient, error)
	// Session management
	StartSession(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Status, error)
	EndSession(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Status, error)
}

type pipelineComputeClient struct {
	cc *grpc.ClientConn
}

func NewPipelineComputeClient(cc *grpc.ClientConn) PipelineComputeClient {
	return &pipelineComputeClient{cc}
}

func (c *pipelineComputeClient) CreatePipelines(ctx context.Context, in *PipelineCreateRequest, opts ...grpc.CallOption) (PipelineCompute_CreatePipelinesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PipelineCompute_serviceDesc.Streams[0], c.cc, "/pipeline.PipelineCompute/CreatePipelines", opts...)
	if err != nil {
		return nil, err
	}
	x := &pipelineComputeCreatePipelinesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PipelineCompute_CreatePipelinesClient interface {
	Recv() (*PipelineCreateResult, error)
	grpc.ClientStream
}

type pipelineComputeCreatePipelinesClient struct {
	grpc.ClientStream
}

func (x *pipelineComputeCreatePipelinesClient) Recv() (*PipelineCreateResult, error) {
	m := new(PipelineCreateResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pipelineComputeClient) ExecutePipeline(ctx context.Context, in *PipelineExecuteRequest, opts ...grpc.CallOption) (PipelineCompute_ExecutePipelineClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PipelineCompute_serviceDesc.Streams[1], c.cc, "/pipeline.PipelineCompute/ExecutePipeline", opts...)
	if err != nil {
		return nil, err
	}
	x := &pipelineComputeExecutePipelineClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PipelineCompute_ExecutePipelineClient interface {
	Recv() (*PipelineExecuteResult, error)
	grpc.ClientStream
}

type pipelineComputeExecutePipelineClient struct {
	grpc.ClientStream
}

func (x *pipelineComputeExecutePipelineClient) Recv() (*PipelineExecuteResult, error) {
	m := new(PipelineExecuteResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pipelineComputeClient) StartSession(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/pipeline.PipelineCompute/StartSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineComputeClient) EndSession(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/pipeline.PipelineCompute/EndSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PipelineCompute service

type PipelineComputeServer interface {
	// Train step - multiple result messages returned via GRPC streaming.
	CreatePipelines(*PipelineCreateRequest, PipelineCompute_CreatePipelinesServer) error
	// Predict step - multiple results messages returned via GRPC streaming.
	ExecutePipeline(*PipelineExecuteRequest, PipelineCompute_ExecutePipelineServer) error
	// Session management
	StartSession(context.Context, *SessionRequest) (*Status, error)
	EndSession(context.Context, *SessionRequest) (*Status, error)
}

func RegisterPipelineComputeServer(s *grpc.Server, srv PipelineComputeServer) {
	s.RegisterService(&_PipelineCompute_serviceDesc, srv)
}

func _PipelineCompute_CreatePipelines_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PipelineCreateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PipelineComputeServer).CreatePipelines(m, &pipelineComputeCreatePipelinesServer{stream})
}

type PipelineCompute_CreatePipelinesServer interface {
	Send(*PipelineCreateResult) error
	grpc.ServerStream
}

type pipelineComputeCreatePipelinesServer struct {
	grpc.ServerStream
}

func (x *pipelineComputeCreatePipelinesServer) Send(m *PipelineCreateResult) error {
	return x.ServerStream.SendMsg(m)
}

func _PipelineCompute_ExecutePipeline_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PipelineExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PipelineComputeServer).ExecutePipeline(m, &pipelineComputeExecutePipelineServer{stream})
}

type PipelineCompute_ExecutePipelineServer interface {
	Send(*PipelineExecuteResult) error
	grpc.ServerStream
}

type pipelineComputeExecutePipelineServer struct {
	grpc.ServerStream
}

func (x *pipelineComputeExecutePipelineServer) Send(m *PipelineExecuteResult) error {
	return x.ServerStream.SendMsg(m)
}

func _PipelineCompute_StartSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineComputeServer).StartSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pipeline.PipelineCompute/StartSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineComputeServer).StartSession(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineCompute_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineComputeServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pipeline.PipelineCompute/EndSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineComputeServer).EndSession(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PipelineCompute_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pipeline.PipelineCompute",
	HandlerType: (*PipelineComputeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartSession",
			Handler:    _PipelineCompute_StartSession_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _PipelineCompute_EndSession_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreatePipelines",
			Handler:       _PipelineCompute_CreatePipelines_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecutePipeline",
			Handler:       _PipelineCompute_ExecutePipeline_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pipeline_service.proto",
}

func init() { proto.RegisterFile("pipeline_service.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 883 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0x9d, 0xd4, 0x69, 0x4e, 0xd2, 0x64, 0x7a, 0xd4, 0x56, 0xde, 0x8a, 0xa5, 0x2b, 0x73,
	0x41, 0x15, 0x50, 0xc5, 0x16, 0xae, 0x10, 0x37, 0x8e, 0xeb, 0x16, 0x4b, 0x4e, 0x5d, 0xc6, 0xc9,
	0x8a, 0x4a, 0x48, 0x96, 0x9b, 0xcc, 0x82, 0xb5, 0xcd, 0x0f, 0x9e, 0xf1, 0x8a, 0xb7, 0xe0, 0x21,
	0xb8, 0xe6, 0x11, 0x78, 0x08, 0x6e, 0xb9, 0xe4, 0x49, 0xd0, 0xcc, 0xd8, 0xf9, 0xeb, 0x2e, 0xb0,
	0x2b, 0x21, 0xee, 0x3a, 0xdf, 0x77, 0xe6, 0xcc, 0x39, 0x5f, 0xbf, 0xaf, 0x2e, 0x1c, 0x2f, 0xb2,
	0x05, 0x7b, 0xc8, 0x66, 0x2c, 0xe1, 0x2c, 0x7f, 0x9d, 0x8d, 0xd9, 0xf9, 0x22, 0x9f, 0x8b, 0x39,
	0xee, 0x55, 0xb8, 0x93, 0x80, 0xf5, 0x35, 0x4b, 0x27, 0x2c, 0xc7, 0xa7, 0x00, 0x9c, 0x71, 0x9e,
	0xcd, 0x67, 0x49, 0x36, 0xb1, 0x8d, 0x67, 0xc6, 0x59, 0x93, 0x36, 0x4b, 0x24, 0x98, 0xe0, 0x07,
	0xd0, 0x14, 0xd9, 0x94, 0x71, 0x91, 0x4e, 0x17, 0xb6, 0xa9, 0xd9, 0x25, 0x80, 0x36, 0x34, 0x5e,
	0xb3, 0x5c, 0x96, 0xda, 0x35, 0xc5, 0x55, 0x47, 0xe7, 0x0b, 0xb0, 0x62, 0x91, 0x8a, 0x82, 0xe3,
	0x31, 0x58, 0x39, 0xe3, 0xc5, 0x83, 0x50, 0xcd, 0x77, 0x69, 0x79, 0x42, 0x84, 0x7a, 0x36, 0x7b,
	0x39, 0x2f, 0x9b, 0xaa, 0x9f, 0x9d, 0xef, 0xc0, 0xa2, 0x9a, 0x3d, 0x03, 0xeb, 0x07, 0x35, 0xa0,
	0xba, 0xd5, 0xba, 0x20, 0xe7, 0xd5, 0xec, 0xe7, 0x7a, 0x70, 0x5a, 0xf2, 0xb2, 0x92, 0xab, 0x97,
	0x54, 0xa7, 0x8d, 0x4a, 0x3d, 0x01, 0x2d, 0x79, 0xe7, 0x0e, 0x3a, 0xb1, 0x5e, 0x8c, 0xb2, 0x1f,
	0x0b, 0xc6, 0xdf, 0xe5, 0x95, 0x4d, 0x99, 0xcc, 0x2d, 0x99, 0x9c, 0x3f, 0x4d, 0x38, 0xba, 0x2d,
	0xaf, 0x7a, 0x39, 0x4b, 0x05, 0x7b, 0xf7, 0x27, 0x3e, 0x05, 0x14, 0x79, 0x9a, 0xcd, 0x92, 0x49,
	0x2a, 0x52, 0xce, 0x44, 0x52, 0xe4, 0x99, 0x5c, 0xaa, 0x76, 0xd6, 0xa4, 0x44, 0x31, 0x97, 0x9a,
	0x18, 0xe5, 0x19, 0x47, 0x07, 0xea, 0x22, 0xe5, 0xaf, 0x94, 0xee, 0x9d, 0x8b, 0xce, 0xaa, 0xeb,
	0x30, 0xe5, 0xaf, 0xa8, 0xe2, 0xf0, 0x13, 0x68, 0xf0, 0xe2, 0x5e, 0x02, 0x76, 0x5d, 0x95, 0x1d,
	0xac, 0x69, 0xa3, 0x09, 0x5a, 0x55, 0xc8, 0x41, 0xe7, 0x85, 0x58, 0x14, 0xc2, 0xde, 0x55, 0xb5,
	0x6b, 0x83, 0x46, 0x0a, 0xa7, 0x25, 0x2f, 0x2b, 0xa7, 0x4c, 0xe4, 0xd9, 0xd8, 0xb6, 0xb6, 0x2b,
	0x07, 0x0a, 0xa7, 0x25, 0x8f, 0x1f, 0x43, 0x57, 0xa4, 0xf9, 0xf7, 0x4c, 0x24, 0x2f, 0x59, 0x2a,
	0x8a, 0x9c, 0x71, 0xbb, 0xa1, 0xf6, 0xe9, 0x68, 0xf8, 0xaa, 0x44, 0xf1, 0x23, 0xd8, 0x9f, 0x15,
	0xd3, 0xa4, 0xea, 0xc3, 0xed, 0x3d, 0xe5, 0x95, 0xf6, 0xac, 0x98, 0x56, 0xb2, 0x72, 0xe7, 0x17,
	0x03, 0x8e, 0x37, 0x45, 0xf6, 0xe6, 0xd3, 0xc5, 0x03, 0x13, 0x0c, 0x4f, 0xa1, 0xa5, 0x6d, 0xa5,
	0x45, 0x33, 0xd4, 0x23, 0xa0, 0x21, 0x25, 0xd7, 0x6a, 0x3b, 0xf3, 0x5f, 0x6f, 0x57, 0xfb, 0x87,
	0xed, 0x0e, 0x61, 0x97, 0x8f, 0xe7, 0x39, 0x53, 0xe2, 0x9a, 0x54, 0x1f, 0x9c, 0xdf, 0x0d, 0x38,
	0xdc, 0xb6, 0xc2, 0x7f, 0x65, 0x69, 0xb9, 0xf7, 0x32, 0xeb, 0xd9, 0xa4, 0x0c, 0x21, 0x54, 0x50,
	0x30, 0xc1, 0x4b, 0x68, 0x8f, 0x4b, 0x91, 0x02, 0x99, 0xb6, 0xba, 0x6a, 0xf8, 0x6c, 0xd5, 0xf0,
	0xcd, 0x82, 0xd2, 0x8d, 0x5b, 0xce, 0xcf, 0x6b, 0xca, 0xfb, 0x3f, 0xb1, 0x71, 0xf1, 0x3e, 0xfe,
	0xde, 0x9a, 0xd5, 0x7c, 0x34, 0x6b, 0x0f, 0x0e, 0x04, 0xe3, 0x62, 0xd3, 0xff, 0x35, 0xf5, 0xab,
	0xec, 0x4a, 0x62, 0xcd, 0xfe, 0xce, 0xaf, 0xc6, 0x2a, 0x70, 0xcb, 0x89, 0xfe, 0x3f, 0x99, 0xb7,
	0xfc, 0x57, 0xdf, 0xf6, 0x5f, 0xaf, 0x07, 0x75, 0x95, 0x32, 0x84, 0x8e, 0x17, 0xba, 0x71, 0x1c,
	0x5c, 0x05, 0x9e, 0x3b, 0x0c, 0xa2, 0x1b, 0xb2, 0x83, 0x1d, 0x00, 0xea, 0x5f, 0x53, 0x3f, 0x8e,
	0xe5, 0xd9, 0xe8, 0xdd, 0x43, 0xa3, 0x4c, 0x27, 0x3e, 0x81, 0xa3, 0x7e, 0x70, 0xe3, 0xd2, 0xbb,
	0xe4, 0xd1, 0xad, 0xa7, 0xf0, 0x64, 0x30, 0x0a, 0x87, 0x81, 0x22, 0xb6, 0x69, 0x63, 0x49, 0x87,
	0x6e, 0xdf, 0x0f, 0xb7, 0x69, 0xb3, 0x37, 0x06, 0x4b, 0xfb, 0x1e, 0xbb, 0xd0, 0xd2, 0x2d, 0x54,
	0x25, 0xd9, 0x91, 0xc0, 0x2d, 0x8d, 0xfa, 0x6e, 0x3f, 0x08, 0x83, 0xe1, 0x1d, 0x31, 0xf0, 0x00,
	0xf6, 0xaf, 0xfd, 0x1b, 0x9f, 0xba, 0x61, 0x12, 0x7b, 0x11, 0xf5, 0x89, 0x29, 0x47, 0x5e, 0x75,
	0x27, 0x35, 0x3c, 0x04, 0xb2, 0x5a, 0x21, 0x79, 0xe1, 0x86, 0x23, 0x9f, 0xd4, 0x7b, 0x7f, 0x18,
	0x60, 0xe9, 0xcc, 0x60, 0x1b, 0xf6, 0x5c, 0xcf, 0x1b, 0x51, 0xd7, 0xbb, 0x23, 0x3b, 0xb8, 0x0f,
	0xcd, 0x5b, 0xea, 0x7b, 0x81, 0x5e, 0x18, 0x01, 0x2c, 0xea, 0x7b, 0x6e, 0x18, 0x12, 0x13, 0x2d,
	0x30, 0xaf, 0x9e, 0x93, 0x9a, 0xbc, 0x70, 0xf5, 0x3c, 0x19, 0x04, 0x1e, 0x8d, 0x48, 0xbd, 0x3a,
	0xb9, 0xf2, 0xb4, 0x8b, 0x2d, 0x68, 0xd0, 0xc8, 0x4b, 0xdc, 0x91, 0x47, 0x2c, 0x49, 0x85, 0xd1,
	0x75, 0x12, 0x46, 0x71, 0x4c, 0x1a, 0x72, 0x90, 0x81, 0xef, 0xde, 0x24, 0xf1, 0x37, 0x23, 0x97,
	0xfa, 0x97, 0x89, 0x4f, 0x29, 0xd9, 0x93, 0x32, 0xd2, 0x28, 0x1a, 0x26, 0x8f, 0xa8, 0x26, 0x1e,
	0xc1, 0x81, 0x42, 0xdd, 0x7e, 0x1c, 0x85, 0xa3, 0xa1, 0xaf, 0x60, 0x40, 0x1b, 0x0e, 0x07, 0xfe,
	0x65, 0x50, 0x12, 0xf1, 0x92, 0x69, 0xc9, 0x01, 0xe9, 0x05, 0x69, 0x5f, 0xfc, 0x66, 0x42, 0x77,
	0x19, 0x9e, 0xf9, 0x74, 0x51, 0x08, 0x86, 0x2f, 0xa0, 0xab, 0x73, 0xb4, 0xfc, 0xa3, 0x85, 0xa7,
	0x6f, 0x8b, 0x5a, 0x19, 0xa0, 0x93, 0x0f, 0xdf, 0x5e, 0x20, 0xdd, 0xe3, 0xec, 0x7c, 0x66, 0xe0,
	0xb7, 0xd0, 0x2d, 0x4d, 0x5e, 0x95, 0xe0, 0x1b, 0x22, 0xbc, 0x99, 0xcc, 0x93, 0xd3, 0xbf, 0xa9,
	0x58, 0x76, 0xfe, 0x0a, 0xda, 0xb1, 0x48, 0x73, 0x51, 0x7e, 0x18, 0xd1, 0x5e, 0xcb, 0xc0, 0xc6,
	0xb7, 0xf2, 0xe4, 0x51, 0x3a, 0x9c, 0x1d, 0xfc, 0x12, 0xc0, 0x9f, 0x4d, 0xde, 0xeb, 0xee, 0xbd,
	0xa5, 0xfe, 0x27, 0xf9, 0xfc, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xca, 0x53, 0xdf, 0x47, 0xad,
	0x08, 0x00, 0x00,
}
